## 什么是面向对象？

在Java中，面向对象是一种编程范式，它将现实世界的事物抽象成对象，通过对象之间的交互来构建程序。面向对象编程（Object-Oriented Programming，OOP）的核心思想是以对象为中心，通过封装、继承和多态等概念来组织和管理代码，使得代码更加模块化、灵活和易于扩展。以下是在Java中理解面向对象的关键概念：

1. **类和对象：**
类是一个模板或蓝图，用来定义对象的属性和方法。对象是类的实例化，是具体的实体。在Java中，通过定义类来描述对象的属性和行为，然后根据类创建对象实例，使用这些对象来完成具体的任务。

2. **封装（Encapsulation）：**
封装是面向对象的重要特性之一。它指的是将数据和方法封装在一个对象中，对外部隐藏对象的内部实现细节，只提供公共接口来访问对象的功能。通过封装，可以控制数据的访问权限，并保护对象的状态，提高代码的安全性和可维护性。

3. **继承（Inheritance）：**
继承是面向对象编程的另一个重要特性。它允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的重用和扩展。子类可以继承父类的特性，并且可以在其基础上添加新的属性和方法，或者重写父类的方法。

4. **多态（Polymorphism）：**
多态性允许不同的类对相同的消息做出响应，即不同的类可以对同一方法名做出不同的实现。多态性通过继承和接口实现，它提高了代码的灵活性和扩展性。在Java中，通过方法重写和接口的实现来实现多态性。

5. **抽象类和接口：**
Java中的抽象类和接口是用来实现抽象的概念，它们不能被实例化，只能被子类继承或实现。抽象类可以包含抽象方法和普通方法，而接口只能包含抽象方法和常量。抽象类和接口可以用于定义规范和约定，并且支持多态性。

通过面向对象的理念，Java程序可以更加模块化、易于理解和维护。面向对象的设计可以帮助开发者更好地解决复杂问题，同时也提供了更高效和可扩展的代码结构。Java作为一门面向对象的编程语言，充分体现了面向对象的特性，使得Java程序可以应用面向对象编程的思想来解决各种实际问题。

### 两种编程思想

**OOP：面向对象**

​		面向对象编程是一种编程范式，它将计算机程序组织成相互交互的对象集合。在面向对象编程中，程序被设计成一系列对象，每个对象都是类的实例，具有属性（数据）和方法（行为）。这种方式将现实世界中的事物抽象为对象，并通过对象之间的交互来解决问题。OOP的核心思想是封装、继承和多态。

​	封装：封装指的是将数据和操作封装在一个对象中，对象对外部隐藏内部实现细节，只暴露必要的接口来访问其功能。这样可以提高代码的安全性和可维护性。

​	继承：继承允许一个类继承另一个类的属性和方法，实现代码的重用和扩展。子类可以继承父类的特性，并且可以在其基础上添加新的属性和方法，或者重写父类的方法。

​	多态：多态性允许不同的类对相同的消息做出响应，即不同的类可以对同一方法名做出不同的实现。多态性通过继承和接口实现，提高了代码的灵活性和可扩展性。

Java是一种面向对象编程语言，它通过类、对象、继承、多态等特性来支持面向对象编程的思想。

**POP：面向过程**

​	面向过程编程是一种编程范式，它将计算机程序组织为一系列的过程或函数。在面向过程编程中，程序被设计为一系列的操作步骤，通过按顺序执行这些步骤来解决问题。这种方式主要强调了算法和数据的处理，更加关注计算机执行的步骤，而不是将问题看作是一组交互的对象。

​	在面向过程编程中，通常会使用函数或过程来处理数据，函数接受输入数据并返回输出结果，以实现程序的功能。数据与函数是紧密相关的，数据的处理是通过函数来完成的。

​	面向过程编程对于简单的任务和算法实现可能更加直观和高效，但是对于复杂的问题，面向对象编程更加适合，因为它可以更好地组织和管理代码，提高代码的可重用性和可维护性。

​	Java也可以使用面向过程的编程方式，但它更加强调面向对象编程，因为Java是一种面向对象的编程语言，它的设计和语法更加支持面向对象编程的特性。



### 三个术语

**OOA：面向对象分析**

​	面向对象分析（Object-Oriented Analysis，OOA）是软件工程中的一项活动，旨在识别和描述系统中的对象、类、属性和它们之间的关系。OOA的目标是理解问题领域，并将问题领域中的概念映射到面向对象的模型。在这个阶段，开发者不考虑具体的实现细节，而是关注系统中的对象、对象之间的交互和关系，以及对象的属性和行为。

​	在OOA阶段，开发者通常使用用例图、类图、对象图等建模工具来描述系统的需求和功能，帮助捕捉系统的静态结构和动态行为。这些模型可以帮助开发者更好地理解问题领域，为后续的面向对象设计和编程阶段提供指导。

**OOD：面向对象设计**

​	面向对象设计（Object-Oriented Design，OOD）是在面向对象分析的基础上，将系统的模型转化为实际的软件设计。在OOD阶段，开发者考虑如何将分析阶段得到的对象模型映射到具体的类和接口，以及对象之间的交互和协作关系。

​	在OOD阶段，开发者通常使用类图、序列图、状态图等建模工具，根据需求和问题领域的理解来设计具体的类和类之间的关系，确定类的属性和方法，以及类的继承和组合关系等。OOD的目标是创建一个灵活、可扩展和易于维护的软件设计，以满足系统的需求。

**OOP：面向对象编程**

​	面向对象编程（Object-Oriented Programming，OOP）是将面向对象设计转化为实际的编程实现。在OOP中，开发者通过定义类和对象，实现类的属性和方法，并使用这些对象来完成具体的任务。

​	在Java等面向对象编程语言中，开发者可以直接使用类和对象来创建实例，调用对象的方法，实现数据封装和抽象，以及利用继承和多态等特性。OOP的核心思想是封装、继承和多态，通过这些特性来提高代码的可重用性和灵活性，以及降低代码的复杂性。

​	综上所述，OOA、OOD和OOP是面向对象软件开发过程中的三个关键阶段，它们分别涉及到面向对象分析、设计和编程的不同方面，一起构成了面向对象开发的完整过程。

## 类与对象

### 类

- 是一组相关属性和行为的抽象集合,是一个模板;
- 构建java的最小单位就是类(class)与接口(interface);
- 属性(成员变量)：事物的状态信息；行为(成员方法)：事物的行为，能做什么；

#### 类的定义

- 步骤：定义类名->定义属性->定义方法

```
public class 类名{
    //定义属性(成员变量)
    //定义方法(成员方法)
}
```

#### 类中的无参成员方法

- 格式：

```
修饰符  返回值类型 方法名(){
	//局部变量
	//方法体
    return ;
}
```

#### 类中的有参成员方法

- 格式：

```
修饰符 返回值类型 方法名(参数列表){
		//方法体；
		//return 返回值；
}
```

#### 可变长度的参数

- 可变长参数是一种参数集合，在集合中参数的数量的不确定的，可能为一个或者多个，也可能没有参数；在这个参数集合中的每个参数类型是不确定的，我们将这个参数集合称之为可变的长参数；

- 格式：

  ```java
  修饰符 返回值 方法名(参数类型...参数名){
  	//方法体
  }
  public static void show(String...strings) {
      for (int i = 0; i < strings.length; i++) {
      	System.out.println(strings[i]);
      }
  }
  show("AAA","BBB","CCC");//调用时可以不定数量传入
  ```

- 返回值根据传入的数据类型返回这个类型的数组；

#### 有参与无参方法的注意

1. 修饰符：public、protected、(default)、private；
2. 返回值类型：如果方法执行完毕，不需要返回值就是void，为void的方法只能单独使用，不能用来打印或者赋值使用；如果需要返回一个值，那么就要写返回该值的类型，并且一定要return一个值；
3. 参数列表：参数可以是基本数据类型、也可以是引用数据类型，可以是多个参数；
4. 局部变量：方法中定义的变量；
5. 方法体：方法所要执行的代码；
6. return：返回值为void时，return不能返回值，只能单独使用，结束执行；返回值不为void时，return返回的值必须与要返回的值类型保持一致；
7. 方法的定义不能嵌套，只能定义再类中；
8. 方法的定义没有先后顺序；
9. 一个方法里面可以有多个return语句，但是必须保证程序执行完毕后，只有一个会执行；

#### 成员变量与局部变量区别

1. 位置不同：成员变量在类中，局部变量在方法中；
2. 作用域不同：成员变量在类中，局部变量在方法中；
3. 初始化不同：成员变量有默认值，局部变量没有默认值，必须要赋值才能使用；
4. 在内存中的位置不同：成员变量在堆内存中，局部变量在栈内存中；
5. 生命周期不同：成员变量随着对象的创建而存在，随着对象消失而消失，局部变量随着方法调用而存在，随着方法的调用完成而消失；

### 对象

- 是一类事物的具体体现；
- 对象就是根据类作为模板创建的具体实例；

#### 创建对象

```
类名 对象名 = new 类名();
访问类中的成员：对象名.成员变量；
    		 对象名.成员方法；
```

#### 匿名对象

- 对象的一种简化形式，只需要调用一次时使用；

```java
new 类名().类的方法
```

### 类与对象的关系

- 类是对一种事物的描述，是抽象的；
- 对象是一类事物的实例，是具体的；
- 类是对象的模板，对象是类的实体；
- 类可以创建无数个对象；

## 构造方法

当一个对象被创建时，构造方法可以用来初始化对象，给对象的成员变量赋初始值；

格式：

```
修饰符 构造方法名(参数列表){
	//方法体；
}
```

```java
public class A{
    String name;
    int age;
    public A(){}//没有传入任何参数，就是无参构造方法
    public A(String name,int age){//有参构造方法
        this.nane = name;
        this.age = age;
    }
}
```

1. 如果没有定义构造方法，系统自动给出无参构造方法；如果定义了构造方法，系统将不再提供无参构造方法；
2. 构造方法可以重载；
3. 构造方法的方法名必须与类名一致，没有返回值；
4. 不能return返回一个值；
5. 构造方法在new对象时调用；
6. 构造方法可以调用普通方法，但是普通方法不能调用构造方法；

## 封装

- 将属性隐藏起来，若需访问某一个属性，提供公共方法对其访问；
- 防止该类的代码和数据被其他类随意访问，要访问必须通过制定方法访问；
- 封装可以是代码更容易理解和维护，可以增强代码的安全性；

### 标准代码--JavaBean

1. 所有成员变量都要使用private关键字修饰；
2. 为每一个变量都提供一个get与set方法；
3. 提供一个无参构造方法；
4. 提供一个全参构造方法；

### private关键字

- private关键字是一个权限修饰符，代表私有的；
- 只能用来修饰成员变量与成员方法；
- 被private修饰的成员变量与成员方法只有在本类才可以被访问；
- 要访问被private修饰的成员变量，必须通过提供的getXXX方法与setXXX方法才能访问；

```java
private 数据类型 变量名;
private String name;
public String getName(){//get方法
    return name;
}
public void setName(String name){//set方法
    this.name = name;
}
```

### set方法与get方法

- set方法：不能有返回值，参数类型与成员类型相对应；
- get方法：不能有参数，返回值类型与成员变量相对应；
- 对于基本类型中的boolean类型，get方法写成isXXX方法；

### this关键字

- 代表所在类的当前对象的引用(地址值)，对象自己的引用，用于区分成员变量和成员变量；
- 只能用于属性、方法、构造方法；
- 调用构造方法时，不能用在普通方法中，只能用在构造方法中，且只能在构造方法的首行；
- this关键字不能用在静态方法中，this只与对象有关；

```java
private String name;
public String getName(){//get方法
    return name;
}
public void setName(String name){//set方法
    this.name = name; // 因为当前类的name与传入的形参name相同，使用this关键字表示是当前类的name
}
```

### final关键字

- 修饰符，不可改变；
- 修饰类，被修饰的类不能被继承；
- 修饰方法，被修饰的方法不能被重写；
- 修饰成员变量，被修饰的成员变量只能直接赋值或者在构造方法里面赋值，别的方式就不能修改值；
- 修饰局部变量(基本类型)，被修饰的局部变量只能赋一次值，就再也不能进行再次赋值；
- 修饰局部变量(引用类型)，被修饰的局部变量只能指向一个对象；

### static关键字

- 是一个修饰符，用于修饰成员变量与成员方法；
- 被修饰的成员就是属于类的，而不是属于那一个对象，它随着类的加载而加载；
- 当static 修饰成员变量时，该变量就称为类变量(静态属性)，该类的每个对象都共享同一个类变量的值，任何对象都可以修改类变量；如果其中一个对象修改了类变量，那么其他对象所访问的该类变量就是被修改之后的值；
- 访问修饰的成员变量方式：类名.成员变量名；(当然使用对象来点也是可以的)

```java
static final int NUM = 100 ;//被static与final所修饰的变量就是常量，只读不可写，且只有一份；
```

- 当static修饰成员方法时，该方法就被称为类方法(静态方法)；
- 被修饰的类方法只能调用静态属性与静态方法，不能调用非静态属性和非静态方法，但是非静态属性与非静态方法却可以调用静态属性与静态方法；
- 静态方法中不能使用this关键字；

### 静态变量与成员变量的区别

1. 所属不同：静态变量属于类，而成员变量属于对象；
2. 内存中的存储位置：静态变量存储与方法区的静态区，而成员变量存储于堆内存；
3. 内存中出现时间不同：静态变量随着类的加载而加载，随着类的消失而消失；而成员变量随着对象的创建而存在，随着对象的消失而消失；
4. 调用不同：静态变量可以直接通过类名调用，也可以通过对象调用；而成员变量只能通过对象名调用；

### 重载

- 在同一类中，方法名相同，参数列表不同的现象称为重载；
- 参数列表不同：
  - 1.参数个数不同
  - 2.参数数据类型不同
  - 3.参数顺序不同；
- 构造方法与普通方法都可以重载；
- 重载只和参数列表有关，与返回值无关；

## 代码块

在Java中，被{}括起来的代码称为代码块，根据其位置和声明的不同，可以分为普通代码块、构造代码块、静态代码块、同步代码块；

### 普通代码块

- 在方法或语句中出现的{}就是普通代码块；
- 它的执行顺序就是从上到下，与书写顺序一致；
- 作用域：外面定义的里面可以访问，里面定义的外面不能访问；

```java
public static void main(String[] args) {
		{
			int i = 1;
			System.out.println("普通代码块"+i);
		}
//		System.out.println("普通代码块"+i);报错，外面访问不到里面变量
	}
```

### 构造代码块

- 直接在类中定义且没有加static关键字的代码块称为构造代码块；
- 它的执行是在创建对象是被调用，每次创建对象，构造代码块就会执行一次，并且优先于构造方法执行；
- 给对象初始化；

```java
public class Test {
	{
		System.out.println("构造块1");
	}
	public Test() {
		System.out.println("构造方法");
	}
	{
		System.out.println("构造块2");
	}
	public static void main(String[] args) {
		new Test();	
		/**
		 * 	构造块1
			构造块2
			构造方法
		 */
	}
}
```

### 静态代码块

- 在类中用static关键字包裹起来的代码块被称为静态代码块；
- 它是随着类的加载而执行的，只会执行一次，并优先于主方法；是由类调用的；
- 给类初始化；

```java
public class Test {
	public Test() {
		System.out.println("构造方法");
	}
	static {
		System.out.println("静态代码块");
	}
	{
		System.out.println("构造代码块");
	}
	public static void main(String[] args) {
		new Test();
		/**
		 * 静态代码块 
		 * 构造代码块
		 *  构造方法
		 */
	}
}
```

### 代码块的优先级

- 静态代码块>构造代码块>构造方法>普通代码块

## 包与import

### 包

- 包(package)其实就是目录，特别是比较大的项目，java文件特别多，这种情况应该分目录管理；
- 格式：package 路径名.路径名.XXX.XXX
  - 	报名一般都是小写字母；
  - 	不能重复；
  - 	必须在所有语句第一行；

```java
package mo.lu;
public class ForTest01{
	public static void main(String[] args){
		for(int i = 0; i < 100; i++){
			System.out.println(100);
		}
	}
}
```

### import

- 导包，把不在同一包中的类导过来；
- 格式：import 路径.路径.类名;
  - 在同一包中，不需要导包；
  - 必须写在package之下，class之上；
  - 可以采用 * 通配符引入包下的类：比如import mo.lu.ForTest01;可以直接import mo.lu.*;把路径下面的所有类都导进来；









