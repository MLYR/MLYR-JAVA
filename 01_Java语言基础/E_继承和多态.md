## 继承

​		继承：就是子类继承父类的属性和方法，使得子类对象具有父类相同的属性、相同的行为；子类可以直接访问父类中的非私有的属性和行为；

​		多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么多个类就无需在定义这些属性和行为，只需要继承这个类即可；

​		这个具有多个类中相同的属性和行为的类就被称为父类(基类、超类)；继承了这个类的类就称为子类(派生类)；这种关系就被成为is-a的关系；

> java只支持单继承，不支持多继承；

### 继承的实现

​			class 子类 extends 父类{}

```java
//父类
class A {
	int num = 10;
	public void show() {
		System.out.println(num);
	}
}
//子类继承B父类
class B extends A{

	@Override
	public void show() {
		super.show();
	}
}
public class Test {
	public static void main(String[] args) {
		B b = new B();
		b.show();
	}
}
```

### 继承的优点

1. 提高了代码的复用性；
2. 提高了代码的维护性；
3. 类与类之间产生了关系，为之后的多态做下铺垫；
4. 子类拥有父类非private的属性和方法。
5. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
6. 子类可以用自己的方式实现父类的方法

### 继承之后的注意事项

#### 1. 构造方法

1. 父类中的构造方法只能被调用，不能被继承，使用super()调用；
2. 而且只能在子类的构造方法中调用，完成初始化；
3. 子类创建对象时，会先默认调用父类无参构造，如果父类没有无参构造，就要在子类的构造方法中明确调用父类的有参构造，否则会报错；
4. 明确调用父类中的构造super()必须写在子类构造方法的第一行，最先执行父类构造；

#### 2. 成员变量

1. 子类与父类中没有重名的成员变量时，访问是没有影响的；
2. 子父类中出现同名成员变量时，子类若要访问父类中非私有成员变量时，就要使用super关键字；

#### 3. 成员方法

1. 子类与父类中没有重名的成员方法时，访问是没有影响的；
2. 若子类与父类存在同名的成员方法(重写)，默认调用的是子类中的方法，要调用父类中的就要加上super关键字；

### super关键字

主要有两种使用方式：

- super.成员变量(访问父类中的成员变量)、super.成员方法(访问父类中的成员方法)；
- super()调用父类的无参构造，super(参数…)调用父类的有参构造 ——只能用在子类的构造方法的首行；

> super关键字与this关键字不能一起在构造方法里面使用；

|     特性     |         super          |              this              |
| :----------: | :--------------------: | :----------------------------: |
|     用途     |     引用父类的成员     |       引用当前对象的成员       |
|   所属环境   |      在子类中使用      | 在类的实例方法和构造方法中使用 |
|   访问成员   |   可以访问父类的成员   |     可以访问当前对象的成员     |
| 调用构造方法 | 可以调用父类的构造方法 |  不能调用自身或父类的构造方法  |
| 调用父类方法 |   可以调用父类的方法   |     不能直接调用父类的方法     |

### 继承-重写

- 父类中已有的方法，可以在子类中重写；
- @Override可以检测子类中要重写父类方法的正确性；
- 属性不会被重写

### 重写的规则

1. 构造方法不能被重写；
2. 方法名、参数列表必须完全与被重写的方法相同；
3. final、private、static修饰的方法不能被重写；
4. 子类访问权限 >= 父类访问权限
5. 子类返回值 <= 父类返回值
6. 父类返回值为void，子类必须也是void
7. 父类返回为基本数据类型，子类返回必须为相同的基板类型；
8. 重写后的方法不能为static修饰；
9. 子类抛出的异常 <= 父类被重写方法抛出的异常；

```java
class Animal{//动物父类
   public void move(){//父类方法
      System.out.println("动物可以移动");
   }
}
class Dog extends Animal{ //狗类继承动物类
   @Override
   public void move(){//方法重写
      System.out.println("狗可以跑和走");
   }
   public void bark(){//自己专有的方法
      System.out.println("狗可以吠叫");
   }
}
public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象
      a.move();// 执行 Animal 类的方法
      b.move();//执行 Dog 类的方法
      b.bark();
   }
}
```

### 访问修饰符

|  访问修饰符   |                        可访问性范围                        |              适用位置              |
| :-----------: | :--------------------------------------------------------: | :--------------------------------: |
|    public     |                        对所有类可见                        | 类、接口、成员变量、方法、构造方法 |
|   protected   |                  对同一包内的类和子类可见                  |      成员变量、方法、构造方法      |
| 默认/包内可见 | 对同一包内的类可见，不使用任何修饰符时，默认修饰符为此级别 | 类、接口、成员变量、方法、构造方法 |
|    private    |                       对同一类内可见                       |      成员变量、方法、构造方法      |

下面是Java中的四种访问修饰符以及它们的可访问性范围和适用位置，以表格形式输出：

|  访问修饰符   |                        可访问性范围                        |              适用位置              |
| :-----------: | :--------------------------------------------------------: | :--------------------------------: |
|    public     |                        对所有类可见                        | 类、接口、成员变量、方法、构造方法 |
|   protected   |                  对同一包内的类和子类可见                  |      成员变量、方法、构造方法      |
| 默认/包内可见 | 对同一包内的类可见，不使用任何修饰符时，默认修饰符为此级别 | 类、接口、成员变量、方法、构造方法 |
|    private    |                       对同一类内可见                       |      成员变量、方法、构造方法      |

​		使用这些访问修饰符可以控制类中的成员变量和方法的访问范围，以实现封装和隐藏对象内部细节。以下是各个访问修饰符的具体说明：

1. **public**：
   - 可以被所有类访问，没有访问限制。
   - 在类、接口、成员变量、方法、构造方法中使用。
2. **protected**：
   - 可以被同一包内的类和子类访问。
   - 在成员变量、方法、构造方法中使用。
3. **默认/包内可见**：
   - 没有使用任何修饰符时，默认的访问修饰符。
   - 可以被同一包内的类访问。
   - 在类、接口、成员变量、方法、构造方法中使用。
4. **private**：
   - 只能被同一类内访问，其他类无法访问。
   - 在成员变量、方法、构造方法中使用。

## 多态

- 多态指同一行为，具有多个不同表现形式；
- 程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编写程序时并不确定，而是在程序运行期间才确定；

### 多态的前提条件

1. 继承或者实现【二选一】
2. 方法的重写，子类对父类中某些方法进行重写；
3. 父类引用指向子类对象(向上转型)；

### 多态的体现

- 格式：父类/父接口类型 变量名  = new 子类对象 ；
- 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有。则编译出错，如果有，则执行的是子类重写后的方法(向上转型)

```java
class A {
	public void show() {
		System.out.println("父类A+++++++");
	}
}
class B extends A {
	@Override
	public void show() {
		System.out.println("子类B+++++++");
	}
	public void print() {
		System.out.println("子类中特有的方法");
	}
	public void show1() {
		super.show();// 调用父类中的show方法
	}
}
public class Test_01 {
	public static void main(String[] args) {
		// 父类引用指向子类对象
		A a = new B();// 向上转型
//		a.print();//编译报错，在父类中没有找到该方法
		a.show();// 子类B+++++++
		// 子类重写了父类中的show方法，所以调用的是子类中的
	}
}
```

### 多态的动态绑定与静态绑定

- 绑定：是指一个方法的调用与方法所在的类关联起来；
- 对于java来说，绑定分为静态绑定(前期绑定)与动态绑定(后期绑定);

#### 静态绑定(前期绑定)

- 在程序执行前方法已经被绑定，可以理解为程序编译期的绑定；
- java中final、static、private、构造方法是前期绑定；

#### 动态绑定(后期绑定)

- 后期绑定：在运行时根据具体对象的类型进行绑定；
- 简单来说就是在编译器在编译期间不知道调用那个方法，运行期才能确定；

#### 静态、动态绑定的区别

1. 静态绑定是发生在编译阶段；而动态绑定是在运行阶段；
2. 静态绑定使用的是类信息，而动态绑定使用的是对象信息；
3. 重载方法使用的是静态绑定，重写方法使用的是动态绑定；

```java
class A {
	//此时的show方法与类绑定，是静态绑定
	public static void show() {
		System.out.println("父类A+++++++");
	}
}
class B extends A {
	//这里的show方法并不是父类中show方法的重写，静态方法不能重写，只是重名而已
	public static void show() {
		System.out.println("子类B+++++++");
	}
}
public class Test_01 {
	public static void main(String[] args) {
		A a = new B();
		a.show();//父类A+++++++ ,也可以直接使用类名调用
		//show方法已经与A绑定，使用A类的引用当然调用A中的show方法
		//想要调用B子类中的show方法只有B的引用
		B.show();//子类B+++++++
    }
}
```

### 多态的向上转型与向下转型

#### 向上转型

- 多态本身就是子类类型向父类类型向上转换的过程，这个过程是默认的；
- 也就是多态的前提条件；
- 格式：父类/父接口类型 变量名  = new 子类对象 ；

#### 向下转型

- 父类类型向子类类型向下转换的过程，这个过程是强制的，需要加上小括号强转；
- 向下转型的作用：可以调用子类特有的方法；
- 格式：子类类型 变量名 = (子类类型)父类变量名；
- 向下转型的前提是：父类引用指向子类对象，就是说要想向下转型，必须先要向上转型；

```java
class A {
	public  void show() {
		System.out.println("父类A+++++++");
	}
}
class B extends A {
	@Override
	public void show() {
		System.out.println("子类B+++++++");
	}
	public void print() {
		System.out.println("子类中特有的方法");
	}
}
public class Test_01 {
	public static void main(String[] args) {
		A a = new B();//向上转型
//		a.print();//编译报错，在父类中不能调用子类中的特有方法
		B b = (B)a;//向下转型
		b.print();//调用子类B中的特有方法
	}
}
```

### instanceof关键字

- 可以检查某个引用变量是否属于某个数据类型；
- 格式：变量名 instanceof 数据类型
- 变量属于该数据类型，返回true，否则返回false；

```java
class A {
	public void showww() {
		System.out.println("父类A");
	}
}
class B extends A{
	public void show() {
		System.out.println("子类B");
	}	
}
class C extends A{
	public void show() {
		System.out.println("子类C");
	}	
}
public class Test_01 {
	public static void main(String[] args) {
		A a = new C();//向上转型
//		C c = (C)a;//编译可以通过，但是运行会出错，类型转换错误ClassCastException
		//先判断a是否数据B数据类型
		if (a instanceof B) {//这里是否执行看new谁，new B执行
			B b = (B)a;//向下转型
			b.show();
		}else if (a instanceof C) {//new C执行
			C c = (C)a;//向下转型
			c.show();
		}
	}
}
```

### 多态总结

- 当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量决定可调用的方法；

- 首先会去可调用的方法的父类中寻找，找到了就执行子类中覆盖的该方法就算子类中有现成的该方法，也会去父类寻找，再去子类中执行覆盖重写的方法；